<!doctype html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width" />
  <title>TypeDescriptor</title>
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto:300,300italic,700,700italic">
  <link rel="stylesheet" href="http://cdn.rawgit.com/necolas/normalize.css/master/normalize.css">
  <link rel="stylesheet" href="http://cdn.rawgit.com/milligram/milligram/master/dist/milligram.min.css">
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <h1>TypeDescriptor</h1>

  org.springframework.core.convert.TypeDescriptor


  <div id="test">
    <input type="text" v-model="message">

    <template v-for="m in matchedMethods" :key="m.sig">
      <h3>{{ m.name }}</h3>
      <pre><code>{{ m.mods }} {{ m.name }}(<template v-for="(p, pi) in m.params" :key="p.name"><template v-if="pi != 0">, </template>{{ p.type }}{{ p.dim }} {{ p.name }}</template>)</code></pre>
      <div><p>{{ m.desc }}</p></div>
    </template>
  </div>

  <script src="https://unpkg.com/vue/dist/vue.js"></script>
  <script>
  var app = new Vue({
  el: '#test',
  data: {
    message: '',
    methods: [
              {
          name: 'getObjectType',
          mods: 'public',
          sig: 'getObjectType()',
          desc: ''/*'Variation of {@link #getType()} that accounts for a primitive type by
 returning its object wrapper type.
 <p>This is useful for conversion service implementations that wish to
 normalize to object-based types and not work with primitive types directly.'*/,
          params: [
                      ]
        },
              {
          name: 'getType',
          mods: 'public',
          sig: 'getType()',
          desc: ''/*'The type of the backing class, method parameter, field, or property
 described by this TypeDescriptor.
 <p>Returns primitive types as-is. See {@link #getObjectType()} for a
 variation of this operation that resolves primitive types to their
 corresponding Object types if necessary.'*/,
          params: [
                      ]
        },
              {
          name: 'getResolvableType',
          mods: 'public',
          sig: 'getResolvableType()',
          desc: ''/*'Return the underlying {@link ResolvableType}.'*/,
          params: [
                      ]
        },
              {
          name: 'getSource',
          mods: 'public',
          sig: 'getSource()',
          desc: ''/*'Return the underlying source of the descriptor. Will return a {@link Field},
 {@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}
 was constructed. This method is primarily to provide access to additional
 type information or meta-data that alternative JVM languages may provide.'*/,
          params: [
                      ]
        },
              {
          name: 'narrow',
          mods: 'public',
          sig: 'narrow(java.lang.Object)',
          desc: ''/*'Narrows this {@link TypeDescriptor} by setting its type to the class of the
 provided value.
 <p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor
 is returned unchanged.
 <p>Designed to be called by binding frameworks when they read property, field,
 or method return values. Allows such frameworks to narrow a TypeDescriptor built
 from a declared property, field, or method return value type. For example, a field
 declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}
 if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor
 can then be used to convert the HashMap to some other type. Annotation and nested
 type context is preserved by the narrowed copy.'*/,
          params: [
                          {
                name: 'value',
                dim: '',
                type: 'Object',
              },
                      ]
        },
              {
          name: 'upcast',
          mods: 'public',
          sig: 'upcast(java.lang.Class)',
          desc: ''/*'Cast this {@link TypeDescriptor} to a superclass or implemented interface
 preserving annotations and nested type context.'*/,
          params: [
                          {
                name: 'superType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'getName',
          mods: 'public',
          sig: 'getName()',
          desc: ''/*'Return the name of this type: the fully qualified class name.'*/,
          params: [
                      ]
        },
              {
          name: 'isPrimitive',
          mods: 'public',
          sig: 'isPrimitive()',
          desc: ''/*'Is this type a primitive type?'*/,
          params: [
                      ]
        },
              {
          name: 'getAnnotations',
          mods: 'public',
          sig: 'getAnnotations()',
          desc: ''/*'Return the annotations associated with this type descriptor, if any.'*/,
          params: [
                      ]
        },
              {
          name: 'hasAnnotation',
          mods: 'public',
          sig: 'hasAnnotation(java.lang.Class)',
          desc: ''/*'Determine if this type descriptor has the specified annotation.
 <p>As of Spring Framework 4.2, this method supports arbitrary levels
 of meta-annotations.'*/,
          params: [
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'getAnnotation',
          mods: 'public',
          sig: 'getAnnotation(java.lang.Class)',
          desc: ''/*'Obtain the annotation of the specified {@code annotationType} that is on this type descriptor.
 <p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations.'*/,
          params: [
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'isAssignableTo',
          mods: 'public',
          sig: 'isAssignableTo(org.springframework.core.convert.TypeDescriptor)',
          desc: ''/*'Returns true if an object of this type descriptor can be assigned to the location
 described by the given type descriptor.
 <p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}
 returns {@code true} because a String value can be assigned to a CharSequence variable.
 On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}
 returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers.
 <p>For arrays, collections, and maps, element and key/value types are checked if declared.
 For example, a List&lt;String&gt; field value is assignable to a Collection&lt;CharSequence&gt;
 field, but List&lt;Number&gt; is not assignable to List&lt;Integer&gt;.'*/,
          params: [
                          {
                name: 'typeDescriptor',
                dim: '',
                type: 'TypeDescriptor',
              },
                      ]
        },
              {
          name: 'isCollection',
          mods: 'public',
          sig: 'isCollection()',
          desc: ''/*'Is this type a {@link Collection} type?'*/,
          params: [
                      ]
        },
              {
          name: 'isArray',
          mods: 'public',
          sig: 'isArray()',
          desc: ''/*'Is this type an array type?'*/,
          params: [
                      ]
        },
              {
          name: 'getElementTypeDescriptor',
          mods: 'public',
          sig: 'getElementTypeDescriptor()',
          desc: ''/*'If this type is an array, returns the array's component type.
 If this type is a {@code Stream}, returns the stream's component type.
 If this type is a {@link Collection} and it is parameterized, returns the Collection's element type.
 If the Collection is not parameterized, returns {@code null} indicating the element type is not declared.'*/,
          params: [
                      ]
        },
              {
          name: 'elementTypeDescriptor',
          mods: 'public',
          sig: 'elementTypeDescriptor(java.lang.Object)',
          desc: ''/*'If this type is a {@link Collection} or an array, creates a element TypeDescriptor
 from the provided collection or array element.
 <p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class
 of the provided collection or array element. For example, if this describes a
 {@code java.util.List&lt;java.lang.Number&lt;} and the element argument is an
 {@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}.
 If this describes a {@code java.util.List&lt;?&gt;} and the element argument is an
 {@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}
 as well.
 <p>Annotation and nested type context will be preserved in the narrowed
 TypeDescriptor that is returned.'*/,
          params: [
                          {
                name: 'element',
                dim: '',
                type: 'Object',
              },
                      ]
        },
              {
          name: 'isMap',
          mods: 'public',
          sig: 'isMap()',
          desc: ''/*'Is this type a {@link Map} type?'*/,
          params: [
                      ]
        },
              {
          name: 'getMapKeyTypeDescriptor',
          mods: 'public',
          sig: 'getMapKeyTypeDescriptor()',
          desc: ''/*'If this type is a {@link Map} and its key type is parameterized,
 returns the map's key type. If the Map's key type is not parameterized,
 returns {@code null} indicating the key type is not declared.'*/,
          params: [
                      ]
        },
              {
          name: 'getMapKeyTypeDescriptor',
          mods: 'public',
          sig: 'getMapKeyTypeDescriptor(java.lang.Object)',
          desc: ''/*'If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}
 from the provided map key.
 <p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property
 to the class of the provided map key. For example, if this describes a
 {@code java.util.Map&lt;java.lang.Number, java.lang.String&lt;} and the key
 argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be
 {@code java.lang.Integer}. If this describes a {@code java.util.Map&lt;?, ?&gt;}
 and the key argument is a {@code java.lang.Integer}, the returned
 TypeDescriptor will be {@code java.lang.Integer} as well.
 <p>Annotation and nested type context will be preserved in the narrowed
 TypeDescriptor that is returned.'*/,
          params: [
                          {
                name: 'mapKey',
                dim: '',
                type: 'Object',
              },
                      ]
        },
              {
          name: 'getMapValueTypeDescriptor',
          mods: 'public',
          sig: 'getMapValueTypeDescriptor()',
          desc: ''/*'If this type is a {@link Map} and its value type is parameterized,
 returns the map's value type.
 <p>If the Map's value type is not parameterized, returns {@code null}
 indicating the value type is not declared.'*/,
          params: [
                      ]
        },
              {
          name: 'getMapValueTypeDescriptor',
          mods: 'public',
          sig: 'getMapValueTypeDescriptor(java.lang.Object)',
          desc: ''/*'If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}
 from the provided map value.
 <p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property
 to the class of the provided map value. For example, if this describes a
 {@code java.util.Map&lt;java.lang.String, java.lang.Number&lt;} and the value
 argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be
 {@code java.lang.Integer}. If this describes a {@code java.util.Map&lt;?, ?&gt;}
 and the value argument is a {@code java.lang.Integer}, the returned
 TypeDescriptor will be {@code java.lang.Integer} as well.
 <p>Annotation and nested type context will be preserved in the narrowed
 TypeDescriptor that is returned.'*/,
          params: [
                          {
                name: 'mapValue',
                dim: '',
                type: 'Object',
              },
                      ]
        },
              {
          name: 'equals',
          mods: 'public',
          sig: 'equals(java.lang.Object)',
          desc: ''/*''*/,
          params: [
                          {
                name: 'other',
                dim: '',
                type: 'Object',
              },
                      ]
        },
              {
          name: 'hashCode',
          mods: 'public',
          sig: 'hashCode()',
          desc: ''/*''*/,
          params: [
                      ]
        },
              {
          name: 'toString',
          mods: 'public',
          sig: 'toString()',
          desc: ''/*''*/,
          params: [
                      ]
        },
              {
          name: 'forObject',
          mods: 'public static',
          sig: 'forObject(java.lang.Object)',
          desc: ''/*'Create a new type descriptor for an object.
 <p>Use this factory method to introspect a source object before asking the
 conversion system to convert it to some another type.
 <p>If the provided object is {@code null}, returns {@code null}, else calls
 {@link #valueOf(Class)} to build a TypeDescriptor from the object's class.'*/,
          params: [
                          {
                name: 'source',
                dim: '',
                type: 'Object',
              },
                      ]
        },
              {
          name: 'valueOf',
          mods: 'public static',
          sig: 'valueOf(java.lang.Class)',
          desc: ''/*'Create a new type descriptor from the given type.
 <p>Use this to instruct the conversion system to convert an object to a
 specific target type, when no type location such as a method parameter or
 field is available to provide additional conversion context.
 <p>Generally prefer use of {@link #forObject(Object)} for constructing type
 descriptors from source objects, as it handles the {@code null} object case.'*/,
          params: [
                          {
                name: 'type',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'collection',
          mods: 'public static',
          sig: 'collection(java.lang.Class, org.springframework.core.convert.TypeDescriptor)',
          desc: ''/*'Create a new type descriptor from a {@link java.util.Collection} type.
 <p>Useful for converting to typed Collections.
 <p>For example, a {@code List<String>} could be converted to a
 {@code List<EmailAddress>} by converting to a targetType built with this method.
 The method call to construct such a {@code TypeDescriptor} would look something
 like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class));}'*/,
          params: [
                          {
                name: 'collectionType',
                dim: '',
                type: 'Class',
              },
                          {
                name: 'elementTypeDescriptor',
                dim: '',
                type: 'TypeDescriptor',
              },
                      ]
        },
              {
          name: 'map',
          mods: 'public static',
          sig: 'map(java.lang.Class, org.springframework.core.convert.TypeDescriptor, org.springframework.core.convert.TypeDescriptor)',
          desc: ''/*'Create a new type descriptor from a {@link java.util.Map} type.
 <p>Useful for converting to typed Maps.
 <p>For example, a Map&lt;String, String&gt; could be converted to a Map&lt;Id, EmailAddress&gt;
 by converting to a targetType built with this method:
 The method call to construct such a TypeDescriptor would look something like:
 <pre class="code">
 map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class));
 </pre>'*/,
          params: [
                          {
                name: 'mapType',
                dim: '',
                type: 'Class',
              },
                          {
                name: 'keyTypeDescriptor',
                dim: '',
                type: 'TypeDescriptor',
              },
                          {
                name: 'valueTypeDescriptor',
                dim: '',
                type: 'TypeDescriptor',
              },
                      ]
        },
              {
          name: 'array',
          mods: 'public static',
          sig: 'array(org.springframework.core.convert.TypeDescriptor)',
          desc: ''/*'Create a new type descriptor as an array of the specified type.
 <p>For example to create a {@code Map<String,String>[]} use:
 <pre class="code">
 TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)));
 </pre>'*/,
          params: [
                          {
                name: 'elementTypeDescriptor',
                dim: '',
                type: 'TypeDescriptor',
              },
                      ]
        },
              {
          name: 'nested',
          mods: 'public static',
          sig: 'nested(org.springframework.core.MethodParameter, int)',
          desc: ''/*'Creates a type descriptor for a nested type declared within the method parameter.
 <p>For example, if the methodParameter is a {@code List<String>} and the
 nesting level is 1, the nested type descriptor will be String.class.
 <p>If the methodParameter is a {@code List<List<String>>} and the nesting
 level is 2, the nested type descriptor will also be a String.class.
 <p>If the methodParameter is a {@code Map<Integer, String>} and the nesting
 level is 1, the nested type descriptor will be String, derived from the map value.
 <p>If the methodParameter is a {@code List<Map<Integer, String>>} and the
 nesting level is 2, the nested type descriptor will be String, derived from the map value.
 <p>Returns {@code null} if a nested type cannot be obtained because it was not declared.
 For example, if the method parameter is a {@code List<?>}, the nested type
 descriptor returned will be {@code null}.'*/,
          params: [
                          {
                name: 'methodParameter',
                dim: '',
                type: 'MethodParameter',
              },
                          {
                name: 'nestingLevel',
                dim: '',
                type: 'int',
              },
                      ]
        },
              {
          name: 'nested',
          mods: 'public static',
          sig: 'nested(java.lang.reflect.Field, int)',
          desc: ''/*'Creates a type descriptor for a nested type declared within the field.
 <p>For example, if the field is a {@code List<String>} and the nesting
 level is 1, the nested type descriptor will be {@code String.class}.
 <p>If the field is a {@code List<List<String>>} and the nesting level is
 2, the nested type descriptor will also be a {@code String.class}.
 <p>If the field is a {@code Map<Integer, String>} and the nesting level
 is 1, the nested type descriptor will be String, derived from the map value.
 <p>If the field is a {@code List<Map<Integer, String>>} and the nesting
 level is 2, the nested type descriptor will be String, derived from the map value.
 <p>Returns {@code null} if a nested type cannot be obtained because it was not declared.
 For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}.'*/,
          params: [
                          {
                name: 'field',
                dim: '',
                type: 'Field',
              },
                          {
                name: 'nestingLevel',
                dim: '',
                type: 'int',
              },
                      ]
        },
              {
          name: 'nested',
          mods: 'public static',
          sig: 'nested(org.springframework.core.convert.Property, int)',
          desc: ''/*'Creates a type descriptor for a nested type declared within the property.
 <p>For example, if the property is a {@code List<String>} and the nesting
 level is 1, the nested type descriptor will be {@code String.class}.
 <p>If the property is a {@code List<List<String>>} and the nesting level
 is 2, the nested type descriptor will also be a {@code String.class}.
 <p>If the property is a {@code Map<Integer, String>} and the nesting level
 is 1, the nested type descriptor will be String, derived from the map value.
 <p>If the property is a {@code List<Map<Integer, String>>} and the nesting
 level is 2, the nested type descriptor will be String, derived from the map value.
 <p>Returns {@code null} if a nested type cannot be obtained because it was not declared.
 For example, if the property is a {@code List<?>}, the nested type descriptor
 returned will be {@code null}.'*/,
          params: [
                          {
                name: 'property',
                dim: '',
                type: 'Property',
              },
                          {
                name: 'nestingLevel',
                dim: '',
                type: 'int',
              },
                      ]
        },
          ]
  },
  methods: {
    show: function() {
      alert(this.message);
    }
  },
  computed: {
    up: function() {
      return this.message.toUpperCase();
    },
    matchedMethods: function() {
      var a = this;
      return this.methods.filter(function(m) {
        return m.name.toLowerCase().indexOf(a.message.toLowerCase()) !== -1;
      });
    }
  }
});  
  </script>
</body>
</html>


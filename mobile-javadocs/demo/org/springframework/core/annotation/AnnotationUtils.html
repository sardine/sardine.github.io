<!doctype html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width" />
  <title>AnnotationUtils</title>
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto:300,300italic,700,700italic">
  <link rel="stylesheet" href="http://cdn.rawgit.com/necolas/normalize.css/master/normalize.css">
  <link rel="stylesheet" href="http://cdn.rawgit.com/milligram/milligram/master/dist/milligram.min.css">
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <h1>AnnotationUtils</h1>

  org.springframework.core.annotation.AnnotationUtils


  <div id="test">
    <input type="text" v-model="message">

    <template v-for="m in matchedMethods" :key="m.sig">
      <h3>{{ m.name }}</h3>
      <pre><code>{{ m.mods }} {{ m.name }}(<template v-for="(p, pi) in m.params" :key="p.name"><template v-if="pi != 0">, </template>{{ p.type }}{{ p.dim }} {{ p.name }}</template>)</code></pre>
      <div><p>{{ m.desc }}</p></div>
    </template>
  </div>

  <script src="https://unpkg.com/vue/dist/vue.js"></script>
  <script>
  var app = new Vue({
  el: '#test',
  data: {
    message: '',
    methods: [
              {
          name: 'getAnnotation',
          mods: 'public static',
          sig: 'getAnnotation(java.lang.annotation.Annotation, java.lang.Class)',
          desc: ''/*'Get a single {@link Annotation} of {@code annotationType} from the supplied
 annotation: either the given annotation itself or a direct meta-annotation
 thereof.
 <p>Note that this method supports only a single level of meta-annotations.
 For support for arbitrary levels of meta-annotations, use one of the
 {@code find*()} methods instead.'*/,
          params: [
                          {
                name: 'ann',
                dim: '',
                type: 'Annotation',
              },
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'getAnnotation',
          mods: 'public static',
          sig: 'getAnnotation(java.lang.reflect.AnnotatedElement, java.lang.Class)',
          desc: ''/*'Get a single {@link Annotation} of {@code annotationType} from the supplied
 {@link AnnotatedElement}, where the annotation is either <em>present</em> or
 <em>meta-present</em> on the {@code AnnotatedElement}.
 <p>Note that this method supports only a single level of meta-annotations.
 For support for arbitrary levels of meta-annotations, use
 {@link #findAnnotation(AnnotatedElement, Class)} instead.'*/,
          params: [
                          {
                name: 'annotatedElement',
                dim: '',
                type: 'AnnotatedElement',
              },
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'getAnnotation',
          mods: 'public static',
          sig: 'getAnnotation(java.lang.reflect.Method, java.lang.Class)',
          desc: ''/*'Get a single {@link Annotation} of {@code annotationType} from the
 supplied {@link Method}, where the annotation is either <em>present</em>
 or <em>meta-present</em> on the method.
 <p>Correctly handles bridge {@link Method Methods} generated by the compiler.
 <p>Note that this method supports only a single level of meta-annotations.
 For support for arbitrary levels of meta-annotations, use
 {@link #findAnnotation(Method, Class)} instead.'*/,
          params: [
                          {
                name: 'method',
                dim: '',
                type: 'Method',
              },
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'getAnnotations',
          mods: 'public static',
          sig: 'getAnnotations(java.lang.reflect.AnnotatedElement)',
          desc: ''/*'Get all {@link Annotation Annotations} that are <em>present</em> on the
 supplied {@link AnnotatedElement}.
 <p>Meta-annotations will <em>not</em> be searched.'*/,
          params: [
                          {
                name: 'annotatedElement',
                dim: '',
                type: 'AnnotatedElement',
              },
                      ]
        },
              {
          name: 'getAnnotations',
          mods: 'public static',
          sig: 'getAnnotations(java.lang.reflect.Method)',
          desc: ''/*'Get all {@link Annotation Annotations} that are <em>present</em> on the
 supplied {@link Method}.
 <p>Correctly handles bridge {@link Method Methods} generated by the compiler.
 <p>Meta-annotations will <em>not</em> be searched.'*/,
          params: [
                          {
                name: 'method',
                dim: '',
                type: 'Method',
              },
                      ]
        },
              {
          name: 'getRepeatableAnnotations',
          mods: 'public static',
          sig: 'getRepeatableAnnotations(java.lang.reflect.AnnotatedElement, java.lang.Class)',
          desc: ''/*'Get the <em>repeatable</em> {@linkplain Annotation annotations} of
 {@code annotationType} from the supplied {@link AnnotatedElement}, where
 such annotations are either <em>present</em>, <em>indirectly present</em>,
 or <em>meta-present</em> on the element.
 <p>This method mimics the functionality of Java 8's
 {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}
 with support for automatic detection of a <em>container annotation</em>
 declared via @{@link java.lang.annotation.Repeatable} (when running on
 Java 8 or higher) and with additional support for meta-annotations.
 <p>Handles both single annotations and annotations nested within a
 <em>container annotation</em>.
 <p>Correctly handles <em>bridge methods</em> generated by the
 compiler if the supplied element is a {@link Method}.
 <p>Meta-annotations will be searched if the annotation is not
 <em>present</em> on the supplied element.'*/,
          params: [
                          {
                name: 'annotatedElement',
                dim: '',
                type: 'AnnotatedElement',
              },
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'getRepeatableAnnotations',
          mods: 'public static',
          sig: 'getRepeatableAnnotations(java.lang.reflect.AnnotatedElement, java.lang.Class, java.lang.Class)',
          desc: ''/*'Get the <em>repeatable</em> {@linkplain Annotation annotations} of
 {@code annotationType} from the supplied {@link AnnotatedElement}, where
 such annotations are either <em>present</em>, <em>indirectly present</em>,
 or <em>meta-present</em> on the element.
 <p>This method mimics the functionality of Java 8's
 {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}
 with additional support for meta-annotations.
 <p>Handles both single annotations and annotations nested within a
 <em>container annotation</em>.
 <p>Correctly handles <em>bridge methods</em> generated by the
 compiler if the supplied element is a {@link Method}.
 <p>Meta-annotations will be searched if the annotation is not
 <em>present</em> on the supplied element.'*/,
          params: [
                          {
                name: 'annotatedElement',
                dim: '',
                type: 'AnnotatedElement',
              },
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                          {
                name: 'containerAnnotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'getDeclaredRepeatableAnnotations',
          mods: 'public static',
          sig: 'getDeclaredRepeatableAnnotations(java.lang.reflect.AnnotatedElement, java.lang.Class)',
          desc: ''/*'Get the declared <em>repeatable</em> {@linkplain Annotation annotations}
 of {@code annotationType} from the supplied {@link AnnotatedElement},
 where such annotations are either <em>directly present</em>,
 <em>indirectly present</em>, or <em>meta-present</em> on the element.
 <p>This method mimics the functionality of Java 8's
 {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}
 with support for automatic detection of a <em>container annotation</em>
 declared via @{@link java.lang.annotation.Repeatable} (when running on
 Java 8 or higher) and with additional support for meta-annotations.
 <p>Handles both single annotations and annotations nested within a
 <em>container annotation</em>.
 <p>Correctly handles <em>bridge methods</em> generated by the
 compiler if the supplied element is a {@link Method}.
 <p>Meta-annotations will be searched if the annotation is not
 <em>present</em> on the supplied element.'*/,
          params: [
                          {
                name: 'annotatedElement',
                dim: '',
                type: 'AnnotatedElement',
              },
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'getDeclaredRepeatableAnnotations',
          mods: 'public static',
          sig: 'getDeclaredRepeatableAnnotations(java.lang.reflect.AnnotatedElement, java.lang.Class, java.lang.Class)',
          desc: ''/*'Get the declared <em>repeatable</em> {@linkplain Annotation annotations}
 of {@code annotationType} from the supplied {@link AnnotatedElement},
 where such annotations are either <em>directly present</em>,
 <em>indirectly present</em>, or <em>meta-present</em> on the element.
 <p>This method mimics the functionality of Java 8's
 {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}
 with additional support for meta-annotations.
 <p>Handles both single annotations and annotations nested within a
 <em>container annotation</em>.
 <p>Correctly handles <em>bridge methods</em> generated by the
 compiler if the supplied element is a {@link Method}.
 <p>Meta-annotations will be searched if the annotation is not
 <em>present</em> on the supplied element.'*/,
          params: [
                          {
                name: 'annotatedElement',
                dim: '',
                type: 'AnnotatedElement',
              },
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                          {
                name: 'containerAnnotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'findAnnotation',
          mods: 'public static',
          sig: 'findAnnotation(java.lang.reflect.AnnotatedElement, java.lang.Class)',
          desc: ''/*'Find a single {@link Annotation} of {@code annotationType} on the
 supplied {@link AnnotatedElement}.
 <p>Meta-annotations will be searched if the annotation is not
 <em>directly present</em> on the supplied element.
 <p><strong>Warning</strong>: this method operates generically on
 annotated elements. In other words, this method does not execute
 specialized search algorithms for classes or methods. If you require
 the more specific semantics of {@link #findAnnotation(Class, Class)}
 or {@link #findAnnotation(Method, Class)}, invoke one of those methods
 instead.'*/,
          params: [
                          {
                name: 'annotatedElement',
                dim: '',
                type: 'AnnotatedElement',
              },
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'findAnnotation',
          mods: 'public static',
          sig: 'findAnnotation(java.lang.reflect.Method, java.lang.Class)',
          desc: ''/*'Find a single {@link Annotation} of {@code annotationType} on the supplied
 {@link Method}, traversing its super methods (i.e., from superclasses and
 interfaces) if the annotation is not <em>directly present</em> on the given
 method itself.
 <p>Correctly handles bridge {@link Method Methods} generated by the compiler.
 <p>Meta-annotations will be searched if the annotation is not
 <em>directly present</em> on the method.
 <p>Annotations on methods are not inherited by default, so we need to handle
 this explicitly.'*/,
          params: [
                          {
                name: 'method',
                dim: '',
                type: 'Method',
              },
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'findAnnotation',
          mods: 'public static',
          sig: 'findAnnotation(java.lang.Class, java.lang.Class)',
          desc: ''/*'Find a single {@link Annotation} of {@code annotationType} on the
 supplied {@link Class}, traversing its interfaces, annotations, and
 superclasses if the annotation is not <em>directly present</em> on
 the given class itself.
 <p>This method explicitly handles class-level annotations which are not
 declared as {@link java.lang.annotation.Inherited inherited} <em>as well
 as meta-annotations and annotations on interfaces</em>.
 <p>The algorithm operates as follows:
 <ol>
 <li>Search for the annotation on the given class and return it if found.
 <li>Recursively search through all annotations that the given class declares.
 <li>Recursively search through all interfaces that the given class declares.
 <li>Recursively search through the superclass hierarchy of the given class.
 </ol>
 <p>Note: in this context, the term <em>recursively</em> means that the search
 process continues by returning to step #1 with the current interface,
 annotation, or superclass as the class to look for annotations on.'*/,
          params: [
                          {
                name: 'clazz',
                dim: '',
                type: 'Class',
              },
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'findAnnotationDeclaringClass',
          mods: 'public static',
          sig: 'findAnnotationDeclaringClass(java.lang.Class, java.lang.Class)',
          desc: ''/*'Find the first {@link Class} in the inheritance hierarchy of the
 specified {@code clazz} (including the specified {@code clazz} itself)
 on which an annotation of the specified {@code annotationType} is
 <em>directly present</em>.
 <p>If the supplied {@code clazz} is an interface, only the interface
 itself will be checked; the inheritance hierarchy for interfaces will
 not be traversed.
 <p>Meta-annotations will <em>not</em> be searched.
 <p>The standard {@link Class} API does not provide a mechanism for
 determining which class in an inheritance hierarchy actually declares
 an {@link Annotation}, so we need to handle this explicitly.'*/,
          params: [
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                          {
                name: 'clazz',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'findAnnotationDeclaringClassForTypes',
          mods: 'public static',
          sig: 'findAnnotationDeclaringClassForTypes(java.util.List, java.lang.Class)',
          desc: ''/*'Find the first {@link Class} in the inheritance hierarchy of the
 specified {@code clazz} (including the specified {@code clazz} itself)
 on which at least one of the specified {@code annotationTypes} is
 <em>directly present</em>.
 <p>If the supplied {@code clazz} is an interface, only the interface
 itself will be checked; the inheritance hierarchy for interfaces will
 not be traversed.
 <p>Meta-annotations will <em>not</em> be searched.
 <p>The standard {@link Class} API does not provide a mechanism for
 determining which class in an inheritance hierarchy actually declares
 one of several candidate {@linkplain Annotation annotations}, so we
 need to handle this explicitly.'*/,
          params: [
                          {
                name: 'annotationTypes',
                dim: '',
                type: 'List',
              },
                          {
                name: 'clazz',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'isAnnotationDeclaredLocally',
          mods: 'public static',
          sig: 'isAnnotationDeclaredLocally(java.lang.Class, java.lang.Class)',
          desc: ''/*'Determine whether an annotation of the specified {@code annotationType}
 is declared locally (i.e., <em>directly present</em>) on the supplied
 {@code clazz}.
 <p>The supplied {@link Class} may represent any type.
 <p>Meta-annotations will <em>not</em> be searched.
 <p>Note: This method does <strong>not</strong> determine if the annotation
 is {@linkplain java.lang.annotation.Inherited inherited}. For greater
 clarity regarding inherited annotations, consider using
 {@link #isAnnotationInherited(Class, Class)} instead.'*/,
          params: [
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                          {
                name: 'clazz',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'isAnnotationInherited',
          mods: 'public static',
          sig: 'isAnnotationInherited(java.lang.Class, java.lang.Class)',
          desc: ''/*'Determine whether an annotation of the specified {@code annotationType}
 is <em>present</em> on the supplied {@code clazz} and is
 {@linkplain java.lang.annotation.Inherited inherited} (i.e., not
 <em>directly present</em>).
 <p>Meta-annotations will <em>not</em> be searched.
 <p>If the supplied {@code clazz} is an interface, only the interface
 itself will be checked. In accordance with standard meta-annotation
 semantics in Java, the inheritance hierarchy for interfaces will not
 be traversed. See the {@linkplain java.lang.annotation.Inherited Javadoc}
 for the {@code @Inherited} meta-annotation for further details regarding
 annotation inheritance.'*/,
          params: [
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                          {
                name: 'clazz',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'isAnnotationMetaPresent',
          mods: 'public static',
          sig: 'isAnnotationMetaPresent(java.lang.Class, java.lang.Class)',
          desc: ''/*'Determine if an annotation of type {@code metaAnnotationType} is
 <em>meta-present</em> on the supplied {@code annotationType}.'*/,
          params: [
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                          {
                name: 'metaAnnotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'isInJavaLangAnnotationPackage',
          mods: 'public static',
          sig: 'isInJavaLangAnnotationPackage(java.lang.annotation.Annotation)',
          desc: ''/*'Determine if the supplied {@link Annotation} is defined in the core JDK
 {@code java.lang.annotation} package.'*/,
          params: [
                          {
                name: 'annotation',
                dim: '',
                type: 'Annotation',
              },
                      ]
        },
              {
          name: 'isInJavaLangAnnotationPackage',
          mods: 'public static',
          sig: 'isInJavaLangAnnotationPackage(java.lang.String)',
          desc: ''/*'Determine if the {@link Annotation} with the supplied name is defined
 in the core JDK {@code java.lang.annotation} package.'*/,
          params: [
                          {
                name: 'annotationType',
                dim: '',
                type: 'String',
              },
                      ]
        },
              {
          name: 'getAnnotationAttributes',
          mods: 'public static',
          sig: 'getAnnotationAttributes(java.lang.annotation.Annotation)',
          desc: ''/*'Retrieve the given annotation's attributes as a {@link Map}, preserving all
 attribute types.
 <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}
 with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters
 set to {@code false}.
 <p>Note: This method actually returns an {@link AnnotationAttributes} instance.
 However, the {@code Map} signature has been preserved for binary compatibility.'*/,
          params: [
                          {
                name: 'annotation',
                dim: '',
                type: 'Annotation',
              },
                      ]
        },
              {
          name: 'getAnnotationAttributes',
          mods: 'public static',
          sig: 'getAnnotationAttributes(java.lang.annotation.Annotation, boolean)',
          desc: ''/*'Retrieve the given annotation's attributes as a {@link Map}.
 <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}
 with the {@code nestedAnnotationsAsMap} parameter set to {@code false}.
 <p>Note: This method actually returns an {@link AnnotationAttributes} instance.
 However, the {@code Map} signature has been preserved for binary compatibility.'*/,
          params: [
                          {
                name: 'annotation',
                dim: '',
                type: 'Annotation',
              },
                          {
                name: 'classValuesAsString',
                dim: '',
                type: 'boolean',
              },
                      ]
        },
              {
          name: 'getAnnotationAttributes',
          mods: 'public static',
          sig: 'getAnnotationAttributes(java.lang.annotation.Annotation, boolean, boolean)',
          desc: ''/*'Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.
 <p>This method provides fully recursive annotation reading capabilities on par with
 the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.'*/,
          params: [
                          {
                name: 'annotation',
                dim: '',
                type: 'Annotation',
              },
                          {
                name: 'classValuesAsString',
                dim: '',
                type: 'boolean',
              },
                          {
                name: 'nestedAnnotationsAsMap',
                dim: '',
                type: 'boolean',
              },
                      ]
        },
              {
          name: 'getAnnotationAttributes',
          mods: 'public static',
          sig: 'getAnnotationAttributes(java.lang.reflect.AnnotatedElement, java.lang.annotation.Annotation)',
          desc: ''/*'Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.
 <p>Equivalent to calling {@link #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)}
 with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters
 set to {@code false}.'*/,
          params: [
                          {
                name: 'annotatedElement',
                dim: '',
                type: 'AnnotatedElement',
              },
                          {
                name: 'annotation',
                dim: '',
                type: 'Annotation',
              },
                      ]
        },
              {
          name: 'getAnnotationAttributes',
          mods: 'public static',
          sig: 'getAnnotationAttributes(java.lang.reflect.AnnotatedElement, java.lang.annotation.Annotation, boolean, boolean)',
          desc: ''/*'Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.
 <p>This method provides fully recursive annotation reading capabilities on par with
 the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.'*/,
          params: [
                          {
                name: 'annotatedElement',
                dim: '',
                type: 'AnnotatedElement',
              },
                          {
                name: 'annotation',
                dim: '',
                type: 'Annotation',
              },
                          {
                name: 'classValuesAsString',
                dim: '',
                type: 'boolean',
              },
                          {
                name: 'nestedAnnotationsAsMap',
                dim: '',
                type: 'boolean',
              },
                      ]
        },
              {
          name: 'registerDefaultValues',
          mods: 'public static',
          sig: 'registerDefaultValues(org.springframework.core.annotation.AnnotationAttributes)',
          desc: ''/*'Register the annotation-declared default values for the given attributes,
 if available.'*/,
          params: [
                          {
                name: 'attributes',
                dim: '',
                type: 'AnnotationAttributes',
              },
                      ]
        },
              {
          name: 'postProcessAnnotationAttributes',
          mods: 'public static',
          sig: 'postProcessAnnotationAttributes(java.lang.Object, org.springframework.core.annotation.AnnotationAttributes, boolean)',
          desc: ''/*'Post-process the supplied {@link AnnotationAttributes}, preserving nested
 annotations as {@code Annotation} instances.
 <p>Specifically, this method enforces <em>attribute alias</em> semantics
 for annotation attributes that are annotated with {@link AliasFor @AliasFor}
 and replaces default value placeholders with their original default values.'*/,
          params: [
                          {
                name: 'annotatedElement',
                dim: '',
                type: 'Object',
              },
                          {
                name: 'attributes',
                dim: '',
                type: 'AnnotationAttributes',
              },
                          {
                name: 'classValuesAsString',
                dim: '',
                type: 'boolean',
              },
                      ]
        },
              {
          name: 'getValue',
          mods: 'public static',
          sig: 'getValue(java.lang.annotation.Annotation)',
          desc: ''/*'Retrieve the <em>value</em> of the {@code value} attribute of a
 single-element Annotation, given an annotation instance.'*/,
          params: [
                          {
                name: 'annotation',
                dim: '',
                type: 'Annotation',
              },
                      ]
        },
              {
          name: 'getValue',
          mods: 'public static',
          sig: 'getValue(java.lang.annotation.Annotation, java.lang.String)',
          desc: ''/*'Retrieve the <em>value</em> of a named attribute, given an annotation instance.'*/,
          params: [
                          {
                name: 'annotation',
                dim: '',
                type: 'Annotation',
              },
                          {
                name: 'attributeName',
                dim: '',
                type: 'String',
              },
                      ]
        },
              {
          name: 'getDefaultValue',
          mods: 'public static',
          sig: 'getDefaultValue(java.lang.annotation.Annotation)',
          desc: ''/*'Retrieve the <em>default value</em> of the {@code value} attribute
 of a single-element Annotation, given an annotation instance.'*/,
          params: [
                          {
                name: 'annotation',
                dim: '',
                type: 'Annotation',
              },
                      ]
        },
              {
          name: 'getDefaultValue',
          mods: 'public static',
          sig: 'getDefaultValue(java.lang.annotation.Annotation, java.lang.String)',
          desc: ''/*'Retrieve the <em>default value</em> of a named attribute, given an annotation instance.'*/,
          params: [
                          {
                name: 'annotation',
                dim: '',
                type: 'Annotation',
              },
                          {
                name: 'attributeName',
                dim: '',
                type: 'String',
              },
                      ]
        },
              {
          name: 'getDefaultValue',
          mods: 'public static',
          sig: 'getDefaultValue(java.lang.Class)',
          desc: ''/*'Retrieve the <em>default value</em> of the {@code value} attribute
 of a single-element Annotation, given the {@link Class annotation type}.'*/,
          params: [
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
              {
          name: 'getDefaultValue',
          mods: 'public static',
          sig: 'getDefaultValue(java.lang.Class, java.lang.String)',
          desc: ''/*'Retrieve the <em>default value</em> of a named attribute, given the
 {@link Class annotation type}.'*/,
          params: [
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                          {
                name: 'attributeName',
                dim: '',
                type: 'String',
              },
                      ]
        },
              {
          name: 'synthesizeAnnotation',
          mods: 'public static',
          sig: 'synthesizeAnnotation(A, java.lang.reflect.AnnotatedElement)',
          desc: ''/*'<em>Synthesize</em> an annotation from the supplied {@code annotation}
 by wrapping it in a dynamic proxy that transparently enforces
 <em>attribute alias</em> semantics for annotation attributes that are
 annotated with {@link AliasFor @AliasFor}.'*/,
          params: [
                          {
                name: 'annotation',
                dim: '',
                type: 'Annotation',
              },
                          {
                name: 'annotatedElement',
                dim: '',
                type: 'AnnotatedElement',
              },
                      ]
        },
              {
          name: 'synthesizeAnnotation',
          mods: 'public static',
          sig: 'synthesizeAnnotation(java.util.Map, java.lang.Class, java.lang.reflect.AnnotatedElement)',
          desc: ''/*'<em>Synthesize</em> an annotation from the supplied map of annotation
 attributes by wrapping the map in a dynamic proxy that implements an
 annotation of the specified {@code annotationType} and transparently
 enforces <em>attribute alias</em> semantics for annotation attributes
 that are annotated with {@link AliasFor @AliasFor}.
 <p>The supplied map must contain a key-value pair for every attribute
 defined in the supplied {@code annotationType} that is not aliased or
 does not have a default value. Nested maps and nested arrays of maps
 will be recursively synthesized into nested annotations or nested
 arrays of annotations, respectively.
 <p>Note that {@link AnnotationAttributes} is a specialized type of
 {@link Map} that is an ideal candidate for this method's
 {@code attributes} argument.'*/,
          params: [
                          {
                name: 'attributes',
                dim: '',
                type: 'Map',
              },
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                          {
                name: 'annotatedElement',
                dim: '',
                type: 'AnnotatedElement',
              },
                      ]
        },
              {
          name: 'synthesizeAnnotation',
          mods: 'public static',
          sig: 'synthesizeAnnotation(java.lang.Class)',
          desc: ''/*'<em>Synthesize</em> an annotation from its default attributes values.
 <p>This method simply delegates to
 {@link #synthesizeAnnotation(Map, Class, AnnotatedElement)},
 supplying an empty map for the source attribute values and {@code null}
 for the {@link AnnotatedElement}.'*/,
          params: [
                          {
                name: 'annotationType',
                dim: '',
                type: 'Class',
              },
                      ]
        },
          ]
  },
  methods: {
    show: function() {
      alert(this.message);
    }
  },
  computed: {
    up: function() {
      return this.message.toUpperCase();
    },
    matchedMethods: function() {
      var a = this;
      return this.methods.filter(function(m) {
        return m.name.toLowerCase().indexOf(a.message.toLowerCase()) !== -1;
      });
    }
  }
});  
  </script>
</body>
</html>

